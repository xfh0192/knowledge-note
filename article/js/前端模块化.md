

### 什么是模块

优秀的作者把他们的书分成章节，优秀的程序员把他们的程序分成模块。好的模块是高度独立的，具有特定功能的，可以根据需要对它们进行修改，删除或添加，而不会破坏整个系统。

### 模块化的好处

1. 命名空间。为变量创建私有空间避免命名空间污染
2. 可重用性。
3. 可维护性。尽可能少地依赖其他模块，从而进行独立管理和更新

### 模块化的要点

1. 如何导入模块的依赖（import）
2. 如何定义模块（code）
3. 如何导出模块的接口（exports）

## 旧的模块化规范

#### commonJS

**同步加载模块**。服务端文件在本地，读取快。但是在浏览器，受限于网络传输，使用异步加载更合理。

#### AMD

**异步加载模块**。

## ES6 module

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。

其模块功能主要由两个命令构成：**export** 和 **import**。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。

## ES6 模块与 CommonJS 模块的差异

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
  - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
  - ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
  - 运行时加载: CommonJS 模块就是对象；即在输入时是**先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。**
  - 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，**import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”**

## Nodejs 环境

Nodejs 使用的是 **CommonJS** 规范。

> 注意：从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。


可以在项目的 **package.json** 文件中，指定 **type** 字段为 **module**。

```
{
   "type": "module"
}
```

虽然支持了 es6 模块，但是 nodejs 中还是尽量不要混用

## 关于 es6 module 和 commonjs 的循环加载

### commonjs规范：

加载机制：第一次加载之后，会将模块缓存起来，从而避免循环加载问题

### es6 module

ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

因此，函数定义的时候，使用**函数声明**方式，就可以利用函数提升避免未定义的问题，从而避免了循环引用

```
--- good ---
# 函数声明

function foo() {}

--- bad ---
# 函数表达式

const foo = () => 'foo'

```

---

refer: 
1. https://juejin.im/post/5e3985396fb9a07cde64c489
2. https://es6.ruanyifeng.com/#docs/module-loader