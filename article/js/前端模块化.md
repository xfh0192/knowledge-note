
> 这篇很好：https://es6.ruanyifeng.com/#docs/module

### 什么是模块

优秀的作者把他们的书分成章节，优秀的程序员把他们的程序分成模块。好的模块是高度独立的，具有特定功能的，可以根据需要对它们进行修改，删除或添加，而不会破坏整个系统。

### 模块化的好处

1. 命名空间。为变量创建私有空间避免命名空间污染
2. 可重用性。
3. 可维护性。尽可能少地依赖其他模块，从而进行独立管理和更新

## 旧的模块化规范

#### commonJS

**同步加载模块**。服务端文件在本地，读取快。但是在浏览器，受限于网络传输，使用异步加载更合理。

#### AMD

**异步加载模块**。

## ES6 module

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。

其模块功能主要由两个命令构成：**export** 和 **import**。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。

## 【重点】ES6 模块与 CommonJS 模块的差异

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
  - CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
  - ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
  - 运行时加载: CommonJS 模块就是对象；即在输入时是**先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。**

    ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。
    
    ```
       // CommonJS模块
       let { stat, exists, readfile } = require('fs');

       // 等同于
       let _fs = require('fs');
       let stat = _fs.stat;
       let exists = _fs.exists;
       let readfile = _fs.readfile;  
    ```

    上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

  - 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，**import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”**

    ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。

    ```
      // ES6模块
      import { stat, exists, readFile } from 'fs';
    ```

    上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。

## Nodejs 环境

Nodejs 使用的是 **CommonJS** 规范。

> 注意：从 v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。


可以在项目的 **package.json** 文件中，指定 **type** 字段为 **module**。

```
{
   "type": "module"
}
```

虽然支持了 es6 模块，但是 nodejs 中还是尽量不要混用

## 关于 es6 module 和 commonjs 的循环加载

### commonjs规范：

加载机制：第一次加载之后，会将模块缓存起来，从而避免循环加载问题

### es6 module

ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。

因此，函数定义的时候，使用**函数声明**方式，就可以利用函数提升避免未定义的问题，从而避免了循环引用

```
--- good ---
# 函数声明

function foo() {}

--- bad ---
# 函数表达式

const foo = () => 'foo'

```

---

refer: 
1. https://juejin.im/post/5e3985396fb9a07cde64c489
2. https://es6.ruanyifeng.com/#docs/module-loader