// https://www.nowcoder.com/practice/6d9d69e3898f45169a441632b325c7b4?tpId=37&tqId=21247&tPage=2&rp=&ru=%2Fta%2Fhuawei&qru=%2Fta%2Fhuawei%2Fquestion-ranking


// === 我写的，存在问题：假如出现两个元素相等，最大递增子序列数依然会+1

// let n = 0
// while(n = readline()) {
//     let list = readline()
//     list = list.split(' ')
    
//     // 这个通过
//     // let list = '186 186 150 200 160 130 197 200'.split(' ').map(v => Number(v))
//     // let n = list.length
    
//     // 这个不通过
//     // let list = '692 160 459 759 192 1251 1070 77 365 428 291 1013 521 86 121 87 731 1249 238 861 605 780 103 501 1380 326 683 506 1067 949 625 148 1106 937 659 28 1059 826 98 938 1175 1270 161 790 939 1235 729 1232 1221 390 744 1245 1298 157 391 881 812 1202 714 1287 1126 140 783 717 144 889 795 713 12 151 137 458 374 38 256 1058 1052 642 557 240 294 473 1077 815 153 682 384 520 1016 821 556 418 890 1308 1042 704 1203 1362 168 822 1362 973 282 1256 1229 235 463 408 708 920 950 1193 285 805 408 445 1091 980 761 373 48 588 1086 933 476 874 1166 513 1165 532 129 135 1022 236 1266 1370 365 22 583 1261 756 908 1070 322 1148 1041 935 601 548 784 1270 1306 1166 31 203 1230 523 1336 590 596 673 199 456 827 544 48 270 249 336 209 926 464 402 1074 135 582 1014 750 758 509 380 925 598 241 706 768 729 467 741 1202 49 1206 297 827 1139 1100 372 312 1014 328 678 303 245 382 1228 7 339 215 1193 1214 1007 582 613 695 338 442 196 54 395 232 815 573 807 1199 519 1016 53 1267 835 1090 547 1052 1199 960 1192 841 1025 29 131 1291 1341 182 671 663 609 1177 905 86 907 55 693 1249 59 926 541 1245 1301 57 687 999 92 175 747 788 741 978 139 481 1362 741 419 1153 454 670 969 820 463 879 1075 783 304 1273 773 851 1088 1016 1267 803 589 122 357 5 106 396 98 1099 1152 176 960 1264 8 321 303 1201 832 151 877 977 178 1339 749 358 1192 111 1141 512 590 827 363 1232 685 933 975 1222 850 1348 1236 554 658 115 1337 1016 977 269 62 1086 291 29 99 683 824 1240 100 1 573 1357 149 364 790 536 40 1246 939 263 1161 462 1373 974 712 791 515 1126 370 1245 1052 856 657 1 1292 437 380 315 988 939 1068 618 362 407 1176 362 1206 27 1113 1065 1166 1193 942 637 443 1053 44 1366 200 680 450 636 1271 457 687 1327 1302 888 695 176 790 916 693 444 289 410 1291 1030 155 801 1129 478 1123 424 91 1057 1059 535 142 490 234 982 220 368 385 1203 854 63 50 454 440 1283 737 210 832 75 1045 1110 1326 1056 589 177 161 96 422 118 1352 1113 1295 1146 587 1330 1094 1356 575 724 90 196 766 481 657 79 219 548 392 157 120 678 672 1326 17 1065 704 583 52 589 1378 365 321 1305 463 668 1323 1331 1036 572 278 753 328 1046 1197 846 724 1170 1153 1154 980 614 335 1072 1221 810 129 521 227 723 1043 407 990 1030 239 814 1034 1287 546 759 1327 1140 1142 442 1135 656 1182 744 240 186 1024 274 1185 1226 744 1154 338 24 216 789 285 638 631 1125 945 1025 226 1026 138 1308 504 102 91 619 1186 891 259 982 336 1245 1280 657 243 417 1336 1281 222 95 1010 768 534 778 1033 876 1309 1289 519 1248 1199 39 169 248 207 416 1377 312 1261 96 1143 1289 709 211 1099 904 389 69 1126 784 662 279 94 1318 856 845 670 791 528 629 689 782 574 13 1152 393 1118 53 750 932 827 131 116 248 505 1059 300 91 1309 373 530 1216 310 652 75 1335 1221 273 285 404 511 417 95 443 1134 253 399 115 517 269 1307 1287 1337 875 536 985 692 252 552 1 1280 1043 1066 123 233 1351 858 216 307 1083 293 866 441 1287 633 615 1197 1365 1006 1259 1230 281 718 875 26 770 929 626 765 1132 1086 139 567 1171 766'.split(' ').map(v => Number(v))
//     // let n = list.length

//     let dp1 = getLIS(list)
    
//     let tempList = list.slice().reverse()
//     let dp2 = getLIS(tempList).reverse()  // 需要反回来
    
//     let maxSum = 0
//     for (let i = 0; i < dp1.length; i++) {
//         maxSum = Math.max(maxSum, dp1[i] + dp2[i])
//     }
    
//     console.log(list.length - maxSum + 1)
// }

// function getLIS(list) {
//     let tempArr = [list[0]]
//     let numArr = [1]
//     let maxLenIndex = 0
//     for (let i = 1; i < list.length; i++) {
//         let value = list[i]
//         if (value > tempArr[maxLenIndex - 1]) {
//             // value比前面所有值都大，就直接找到numArr里面最大的值+1
//             numArr[i] = numArr[maxLenIndex] + 1
//             maxLenIndex = i
//             tempArr.push(value)
//         } else {
//             // 获取tempArr中比list[i]小的值集合 tArr
//             // tArr每个值在tempArr对应的index在numArr中的值集合 nArr
//             // nArr中最大的值+1，就是numArr[i]的值
//             let maxLen = getMaxLen(tempArr, numArr, value)
//             numArr[i] = maxLen
//             tempArr.push(value)
//         }
//     }
//     return numArr
// }

// function getMaxLen(tempArr, numArr, value) {
//     let maxLen = numArr[0]
//     // 标记，假如与前面元素的比较前，一直是下降/水平趋势，那么就肯定是1
//     let flag = false
//     for (let i = 0; i < tempArr.length; i++) {
//         let v = tempArr[i]
//         // 一旦出现比value小的元素，说明出现上升趋势了，此时需要算maxLen
//         if (v < value) {
//             maxLen = Math.max(maxLen, numArr[i])
//             flag = true
//         }
//     }
//     return flag ? maxLen + 1 : 1
// }

// ====== 答案 ======

// function binarySearch(arr,len,value){
//   var left = 0,right = len-1
//   var mid
//   while(left<=right){
//       mid=left+parseInt((right-left)/2)
//       if(arr[mid]<value){
//           left=mid+1
//       }else if(arr[mid]>value){
//           right=mid-1
//       }else{
//           return mid
//       }
//   }
//   return left
// }
// function getLIS(arrList){
//   var tmpArr = []
//   var resArr = []
//   tmpArr[0] = arrList[0]
//   resArr[0] = 1
//   var maxlen = 1
//   var pos = 0
//   for(var i=1;i<arrList.length;i++){
//       var value = arrList[i]
//       if(value>tmpArr[maxlen-1]){
//           tmpArr[maxlen]=value
//           ++maxlen
//       }else{
//           pos=binarySearch(tmpArr,maxlen,value)
//           tmpArr[pos]=value
//       }
//       resArr[i]=maxlen
//   }
//   return resArr
// }
// while(num=readline()){
//   var arrList = readline().split(' ').map(n=>parseInt(n))

//   // // 这个通过
//   // let arrList = '186 186 150 200 160 130 197 200'.split(' ').map(v => Number(v))
//   // let n = arrList.length

//   var dp1 = getLIS(arrList)
//   var dp2 = getLIS(arrList.reverse())
//   dp2 = dp2.reverse()
//   var max = 0
//   for(var i=0;i<dp1.length;i++){
//       max = Math.max(dp1[i]+dp2[i],max)
//   }
//   console.log(arrList.length-max+1)
// }

// ==== 中规中矩答案，易于理解。很好的 ====

let n = 0
while(n = readline()) {
  let list = readline().split(' ').map(v => Number(v))
  
  // let list = '692 160 459 759 192 1251 1070 77 365 428 291 1013 521 86 121 87 731 1249 238 861 605 780 103 501 1380 326 683 506 1067 949 625 148 1106 937 659 28 1059 826 98 938 1175 1270 161 790 939 1235 729 1232 1221 390 744 1245 1298 157 391 881 812 1202 714 1287 1126 140 783 717 144 889 795 713 12 151 137 458 374 38 256 1058 1052 642 557 240 294 473 1077 815 153 682 384 520 1016 821 556 418 890 1308 1042 704 1203 1362 168 822 1362 973 282 1256 1229 235 463 408 708 920 950 1193 285 805 408 445 1091 980 761 373 48 588 1086 933 476 874 1166 513 1165 532 129 135 1022 236 1266 1370 365 22 583 1261 756 908 1070 322 1148 1041 935 601 548 784 1270 1306 1166 31 203 1230 523 1336 590 596 673 199 456 827 544 48 270 249 336 209 926 464 402 1074 135 582 1014 750 758 509 380 925 598 241 706 768 729 467 741 1202 49 1206 297 827 1139 1100 372 312 1014 328 678 303 245 382 1228 7 339 215 1193 1214 1007 582 613 695 338 442 196 54 395 232 815 573 807 1199 519 1016 53 1267 835 1090 547 1052 1199 960 1192 841 1025 29 131 1291 1341 182 671 663 609 1177 905 86 907 55 693 1249 59 926 541 1245 1301 57 687 999 92 175 747 788 741 978 139 481 1362 741 419 1153 454 670 969 820 463 879 1075 783 304 1273 773 851 1088 1016 1267 803 589 122 357 5 106 396 98 1099 1152 176 960 1264 8 321 303 1201 832 151 877 977 178 1339 749 358 1192 111 1141 512 590 827 363 1232 685 933 975 1222 850 1348 1236 554 658 115 1337 1016 977 269 62 1086 291 29 99 683 824 1240 100 1 573 1357 149 364 790 536 40 1246 939 263 1161 462 1373 974 712 791 515 1126 370 1245 1052 856 657 1 1292 437 380 315 988 939 1068 618 362 407 1176 362 1206 27 1113 1065 1166 1193 942 637 443 1053 44 1366 200 680 450 636 1271 457 687 1327 1302 888 695 176 790 916 693 444 289 410 1291 1030 155 801 1129 478 1123 424 91 1057 1059 535 142 490 234 982 220 368 385 1203 854 63 50 454 440 1283 737 210 832 75 1045 1110 1326 1056 589 177 161 96 422 118 1352 1113 1295 1146 587 1330 1094 1356 575 724 90 196 766 481 657 79 219 548 392 157 120 678 672 1326 17 1065 704 583 52 589 1378 365 321 1305 463 668 1323 1331 1036 572 278 753 328 1046 1197 846 724 1170 1153 1154 980 614 335 1072 1221 810 129 521 227 723 1043 407 990 1030 239 814 1034 1287 546 759 1327 1140 1142 442 1135 656 1182 744 240 186 1024 274 1185 1226 744 1154 338 24 216 789 285 638 631 1125 945 1025 226 1026 138 1308 504 102 91 619 1186 891 259 982 336 1245 1280 657 243 417 1336 1281 222 95 1010 768 534 778 1033 876 1309 1289 519 1248 1199 39 169 248 207 416 1377 312 1261 96 1143 1289 709 211 1099 904 389 69 1126 784 662 279 94 1318 856 845 670 791 528 629 689 782 574 13 1152 393 1118 53 750 932 827 131 116 248 505 1059 300 91 1309 373 530 1216 310 652 75 1335 1221 273 285 404 511 417 95 443 1134 253 399 115 517 269 1307 1287 1337 875 536 985 692 252 552 1 1280 1043 1066 123 233 1351 858 216 307 1083 293 866 441 1287 633 615 1197 1365 1006 1259 1230 281 718 875 26 770 929 626 765 1132 1086 139 567 1171 766'.split(' ').map(v => Number(v))
  // let n = list.length

  let leftQueen = [] //数据元素从左到右对应的最大递增子序列数
  let rightQueen = [] //数据元素从右到左对应的最大递增子序列数

  for (let i = 0; i < n; i++) {
    leftQueen[i] = 1
    rightQueen[i] = 1
  }

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (list[i] > list[j] && leftQueen[j] + 1 > leftQueen[i]) {
        leftQueen[i] = leftQueen[j] + 1
      }
    }
  }

  list.reverse()

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (list[i] > list[j] && rightQueen[j] + 1 > rightQueen[i]) {
        rightQueen[i] = rightQueen[j] + 1
      }
    }
  }

  rightQueen.reverse()
  
  let max = 0
  for (let i = 0; i < n; i++) {
    max = Math.max(max, leftQueen[i] + rightQueen[i])
  }

  console.log(n - max + 1)
}